<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Composition - Elmish</title> <link rel="shortcut icon" href="/purescript-elmish/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/purescript-elmish/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/purescript-elmish/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/purescript-elmish/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Composition | Elmish</title> <meta name="generator" content="Jekyll v3.9.0" /> <meta property="og:title" content="Composition" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Elmish is a PureScript UI library that (loosely) follows The Elm Architecture implemented as a thin layer on top of React." /> <meta property="og:description" content="Elmish is a PureScript UI library that (loosely) follows The Elm Architecture implemented as a thin layer on top of React." /> <link rel="canonical" href="/purescript-elmish/composition/" /> <meta property="og:url" content="/purescript-elmish/composition/" /> <meta property="og:site_name" content="Elmish" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Composition" /> <script type="application/ld+json"> {"description":"Elmish is a PureScript UI library that (loosely) follows The Elm Architecture implemented as a thin layer on top of React.","headline":"Composition","@type":"WebPage","url":"/purescript-elmish/composition/","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/purescript-elmish/" class="site-title lh-tight"> Elmish </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/purescript-elmish/" class="nav-list-link">Intro</a></li><li class="nav-list-item"><a href="/purescript-elmish/getting-started/" class="nav-list-link">Getting Started</a></li><li class="nav-list-item"><a href="/purescript-elmish/transition/" class="nav-list-link">State Transitions</a></li><li class="nav-list-item active"><a href="/purescript-elmish/composition/" class="nav-list-link active">Composition</a></li><li class="nav-list-item"><a href="/purescript-elmish/dom-elements/" class="nav-list-link">Rendering HTML</a></li><li class="nav-list-item"><a href="/purescript-elmish/read-foreign/" class="nav-list-link">JavaScript interaction</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Elmish" aria-label="Search Elmish" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="composition"> <a href="#composition" class="anchor-heading" aria-labelledby="composition"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Composition </h1> <p>In a real program, it is almost never enough to have all of the UI logic and visuals in one place. Almost always it is beneficial to split up the UI into smaller parts, usually located in separate modules, be it for clarity and maintainability or for reuse.</p> <p>This page describes different patterns of such decomposition supported by Elmish.</p> <ol id="markdown-toc"> <li><a href="#partial-view-functions" id="markdown-toc-partial-view-functions">Partial view functions</a></li> <li><a href="#composing-full-fledged-components" id="markdown-toc-composing-full-fledged-components">Composing full-fledged components</a></li> <li><a href="#dedicated-event-loop" id="markdown-toc-dedicated-event-loop">Dedicated event loop</a></li> <li><a href="#events-from-child-components" id="markdown-toc-events-from-child-components">Events from child components</a></li> </ol> <h2 id="partial-view-functions"> <a href="#partial-view-functions" class="anchor-heading" aria-labelledby="partial-view-functions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Partial view functions </h2> <p>The simplest way to split up a big UI is to extract some parts of its <code class="language-plaintext highlighter-rouge">view</code> function as separate functions, what in some contexts might be called “partial view”. For example, consider the bespoke counter UI:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">State</span> <span class="o">=</span> <span class="p">{</span> <span class="n">count</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span>
<span class="kr">data</span> <span class="kt">Message</span> <span class="o">=</span> <span class="kt">Inc</span> <span class="o">|</span> <span class="kt">Dec</span>

<span class="n">view</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Dispatch</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">view</span> <span class="n">state</span> <span class="n">dispatch</span> <span class="o">=</span>
  <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span>
  <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span> <span class="o">$</span> <span class="s">"The current count is: "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">state</span><span class="o">.</span><span class="n">count</span>
  <span class="p">,</span> <span class="n">button</span> <span class="s">"increase"</span> <span class="p">(</span><span class="n">dispatch</span> <span class="kt">Inc</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">button</span> <span class="s">"decrease"</span> <span class="p">(</span><span class="n">dispatch</span> <span class="kt">Dec</span><span class="p">)</span>
  <span class="p">]</span>

<span class="n">button</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Effect</span> <span class="kt">Unit</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">button</span> <span class="n">text</span> <span class="n">onClick</span> <span class="o">=</span>
  <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span>
  <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">text</span> <span class="o">$</span> <span class="s">"To "</span> <span class="o">&lt;&gt;</span> <span class="n">text</span> <span class="o">&lt;&gt;</span> <span class="s">" the count, click here: "</span>
  <span class="p">,</span> <span class="kt">H</span><span class="o">.</span><span class="n">button_</span> <span class="s">"btn btn-primary"</span> <span class="p">{</span> <span class="n">onClick</span> <span class="p">}</span> <span class="n">text</span>
  <span class="p">]</span>
</code></pre></div></div> <p><img src="/purescript-elmish/counter-1.png" alt="Counter example" /></p> <p>Here, we have extracted the visuals for “increase” and “decrease” buttons as a partial view function named <code class="language-plaintext highlighter-rouge">button</code>, which is then used twice in the main <code class="language-plaintext highlighter-rouge">view</code> function.</p> <p class="callout"><strong>NOTE:</strong> such “partial view” function doesn’t have to be just a visual. As seen in this example, it can produce messages as well.</p> <p>Often, especially with larger partial views, it’s beneficial to name their parameters by gathering them in a record:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">view</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Dispatch</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">view</span> <span class="n">state</span> <span class="n">dispatch</span> <span class="o">=</span>
  <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span>
  <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span> <span class="o">$</span> <span class="s">"The current count is: "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">state</span><span class="o">.</span><span class="n">count</span>
  <span class="p">,</span> <span class="n">button</span> <span class="p">{</span> <span class="n">text</span><span class="o">:</span> <span class="s">"increase"</span><span class="p">,</span> <span class="n">onClick</span><span class="o">:</span> <span class="n">dispatch</span> <span class="kt">Inc</span> <span class="p">}</span>
  <span class="p">,</span> <span class="n">button</span> <span class="p">{</span> <span class="n">text</span><span class="o">:</span> <span class="s">"decrease"</span><span class="p">,</span> <span class="n">onClick</span><span class="o">:</span> <span class="n">dispatch</span> <span class="kt">Dec</span> <span class="p">}</span>
  <span class="p">]</span>

<span class="n">button</span> <span class="o">::</span> <span class="p">{</span> <span class="n">text</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">onClick</span> <span class="o">::</span> <span class="kt">Effect</span> <span class="kt">Unit</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">button</span> <span class="p">{</span> <span class="n">text</span><span class="p">,</span> <span class="n">onClick</span> <span class="p">}</span> <span class="o">=</span>
  <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span>
  <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">text</span> <span class="o">$</span> <span class="s">"To "</span> <span class="o">&lt;&gt;</span> <span class="n">text</span> <span class="o">&lt;&gt;</span> <span class="s">" the count, click here: "</span>
  <span class="p">,</span> <span class="kt">H</span><span class="o">.</span><span class="n">button_</span> <span class="s">"btn btn-primary"</span> <span class="p">{</span> <span class="n">onClick</span> <span class="p">}</span> <span class="n">text</span>
  <span class="p">]</span>
</code></pre></div></div> <h2 id="composing-full-fledged-components"> <a href="#composing-full-fledged-components" class="anchor-heading" aria-labelledby="composing-full-fledged-components"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Composing full-fledged components </h2> <p>Partial view functions are great, because they’re simple, but sometimes it does make sense to package away a whole piece of complex UI logic - either for reuse or just for code organization. This setup is usually referred to as “child components”.</p> <p>For example, let’s say we wanted to create a UI consisting of <em>two</em> such counters as shown above:</p> <p><img src="/purescript-elmish/counter-2.png" alt="Counters composed" /></p> <p>To do this, we would aggregate the two counters’ states, route their messages and state transitions, and compose their views:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Counter</span> <span class="k">as</span> <span class="n">Counter</span>

<span class="c1">-- Aggregate child components' states</span>
<span class="kr">type</span> <span class="kt">State</span> <span class="o">=</span>
  <span class="p">{</span> <span class="n">left</span> <span class="o">::</span> <span class="kt">Counter</span><span class="o">.</span><span class="kt">State</span>
  <span class="p">,</span> <span class="n">right</span> <span class="o">::</span> <span class="kt">Counter</span><span class="o">.</span><span class="kt">State</span>
  <span class="p">}</span>

<span class="c1">-- Aggregate child components' messages</span>
<span class="kr">data</span> <span class="kt">Message</span>
  <span class="o">=</span> <span class="kt">LeftMsg</span> <span class="kt">Counter</span><span class="o">.</span><span class="kt">Message</span>
  <span class="o">|</span> <span class="kt">RightMsg</span> <span class="kt">Counter</span><span class="o">.</span><span class="kt">Message</span>

<span class="n">view</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Dispatch</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">view</span> <span class="n">state</span> <span class="n">dispatch</span> <span class="o">=</span>
  <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">"row"</span>
  <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">"col-6"</span>
    <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">h3</span> <span class="s">""</span> <span class="s">"Left counter"</span>
    <span class="p">,</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">view</span> <span class="n">state</span><span class="o">.</span><span class="n">left</span> <span class="p">(</span><span class="n">dispatch</span> <span class="o">&lt;&lt;&lt;</span> <span class="kt">LeftMsg</span><span class="p">)</span>
    <span class="p">]</span>
  <span class="p">,</span> <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">"col-6"</span>
    <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">h3</span> <span class="s">""</span> <span class="s">"Right counter"</span>
    <span class="p">,</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">view</span> <span class="n">state</span><span class="o">.</span><span class="n">right</span> <span class="p">(</span><span class="n">dispatch</span> <span class="o">&lt;&lt;&lt;</span> <span class="kt">RightMsg</span><span class="p">)</span>
    <span class="p">]</span>
  <span class="p">]</span>
</code></pre></div></div> <p>Note how we’re calling <code class="language-plaintext highlighter-rouge">Counter.view</code> twice, but passing it different states (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and different <code class="language-plaintext highlighter-rouge">Dispatch</code> functions - one wrapping Counter’s messages in <code class="language-plaintext highlighter-rouge">LeftMsg</code> and the other wrapping them in <code class="language-plaintext highlighter-rouge">RightMsg</code>.</p> <p>So far so good. But what about the <code class="language-plaintext highlighter-rouge">update</code> function?</p> <p>Since <code class="language-plaintext highlighter-rouge">Transition</code> is a pair of state + effects (see <a href="transition.md#under-the-hood">Transition: Under the Hood</a>), we could do it the straightforward way:</p> <ol> <li>Call <code class="language-plaintext highlighter-rouge">Counter.update</code></li> <li>Unwrap the resulting <code class="language-plaintext highlighter-rouge">Transition</code> to obtain the new counter state and any effects.</li> <li>Plug the new counter state into the aggregate <code class="language-plaintext highlighter-rouge">State</code></li> <li>Modify the effects to wrap all messages they produce in <code class="language-plaintext highlighter-rouge">LeftMsg</code> (or <code class="language-plaintext highlighter-rouge">RightMsg</code>).</li> <li>Reconstruct <code class="language-plaintext highlighter-rouge">Transition</code> out of the new aggregate <code class="language-plaintext highlighter-rouge">State</code> and the modified effects.</li> </ol> <p>This is what your typical Elm program does, and it would look something like this:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">LeftMsg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="kt">Transition</span> <span class="n">s</span> <span class="n">effs</span> <span class="o">=</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">left</span> <span class="n">m</span>
      <span class="n">state'</span> <span class="o">=</span> <span class="n">state</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">s</span> <span class="p">}</span>
      <span class="n">effs'</span> <span class="o">=</span> <span class="n">map</span> <span class="kt">LeftMsg</span> <span class="o">&lt;$&gt;</span> <span class="n">effs</span>
  <span class="kr">in</span>
    <span class="kt">Transition</span> <span class="n">state'</span> <span class="n">effs'</span>
</code></pre></div></div> <p>This is straightforward, but in practice this becomes very tedious very fast. So instead, we could use the fact that <code class="language-plaintext highlighter-rouge">Transition</code> is a monad (to thread the state via <code class="language-plaintext highlighter-rouge">bind</code>) as well as a <code class="language-plaintext highlighter-rouge">Bifunctor</code> (to wrap the effect messages via <code class="language-plaintext highlighter-rouge">lmap</code>). This would look somewhat like this:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">LeftMsg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">s'</span> <span class="o">&lt;-</span> <span class="n">lmap</span> <span class="kt">LeftMsg</span> <span class="o">$</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">left</span> <span class="n">m</span>
  <span class="n">pure</span> <span class="n">state</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">s'</span> <span class="p">}</span>
</code></pre></div></div> <p class="callout"><strong>NOTE</strong>: See the <a href="/purescript-elmish/transition/">Transition</a> page for a detailed description of how the <code class="language-plaintext highlighter-rouge">do</code> notation works with <code class="language-plaintext highlighter-rouge">Transition</code></p> <p>Or even better: for a straightforward mapping like this, without any extra processing, we could use just the <code class="language-plaintext highlighter-rouge">Bifunctor</code> aspect of <code class="language-plaintext highlighter-rouge">Transition</code> and map both messages and state via <code class="language-plaintext highlighter-rouge">bimap</code>:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">LeftMsg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">bimap</span> <span class="kt">LeftMsg</span> <span class="n">state</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="kr">_</span> <span class="p">}</span> <span class="o">$</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">left</span> <span class="n">m</span>
</code></pre></div></div> <p class="callout"><strong>NOTE</strong>: This syntax works because of how PureScript’s record updates are parsed. The expression <code class="language-plaintext highlighter-rouge">state { left = _ }</code> is a single term, equivalent to a function <code class="language-plaintext highlighter-rouge">\x -&gt; state { left = x }</code></p> <p>Armed with this knowledge, we can now write the full <code class="language-plaintext highlighter-rouge">update</code> function of the composed component:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">Transition</span> <span class="kt">Message</span> <span class="kt">State</span>
<span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">LeftMsg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">bimap</span> <span class="kt">LeftMsg</span> <span class="n">state</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="kr">_</span> <span class="p">}</span> <span class="o">$</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">left</span> <span class="n">m</span>
<span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">RightMsg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">bimap</span> <span class="kt">RightMsg</span> <span class="n">state</span> <span class="p">{</span> <span class="n">right</span> <span class="o">=</span> <span class="kr">_</span> <span class="p">}</span> <span class="o">$</span> <span class="kt">Counter</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">right</span> <span class="n">m</span>
</code></pre></div></div> <p>This mode of composition is sure less tedious than in Elm, but still heavy compared to the partial view functions. Use with care.</p> <h2 id="dedicated-event-loop"> <a href="#dedicated-event-loop" class="anchor-heading" aria-labelledby="dedicated-event-loop"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dedicated event loop </h2> <p>Aggregating child component’s state and message into those of the parent component is the standard composition procedure in The Elm Architecture. Sometimes, however, it turns out to be very inconvenient for no reason.</p> <p>Say we wanted to display two areas of our UI in “collapsible panels” - i.e. a header with a button that shows or hides contents:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">CollapsiblePanel</span> <span class="kr">where</span>

<span class="kr">type</span> <span class="kt">State</span> <span class="o">=</span> <span class="p">{</span> <span class="n">collapsed</span> <span class="o">::</span> <span class="kt">Boolean</span> <span class="p">}</span>
<span class="kr">data</span> <span class="kt">Message</span> <span class="o">=</span> <span class="kt">Toggle</span>

<span class="n">view</span> <span class="o">::</span> <span class="p">{</span> <span class="n">title</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">content</span> <span class="o">::</span> <span class="kt">ReactElement</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Dispatch</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">view</span> <span class="p">{</span> <span class="n">title</span><span class="p">,</span> <span class="n">content</span> <span class="p">}</span> <span class="n">state</span> <span class="n">dispatch</span> <span class="o">=</span>
  <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span>
  <span class="p">[</span> <span class="kt">H</span><span class="o">.</span><span class="n">div_</span> <span class="s">"bg-light"</span> <span class="p">{</span> <span class="n">onClick</span><span class="o">:</span> <span class="n">dispatch</span> <span class="kt">Toggle</span> <span class="p">}</span> <span class="n">title</span>
  <span class="p">,</span> <span class="kr">if</span> <span class="n">collapsed</span>
      <span class="kr">then</span> <span class="kt">H</span><span class="o">.</span><span class="n">empty</span>
      <span class="kr">else</span> <span class="kt">H</span><span class="o">.</span><span class="n">div</span> <span class="s">""</span> <span class="n">content</span>
  <span class="p">]</span>

<span class="n">update</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">Transition</span> <span class="kt">Message</span> <span class="kt">State</span>
<span class="n">update</span> <span class="p">{</span> <span class="n">collapsed</span> <span class="p">}</span> <span class="kt">Toggle</span> <span class="o">=</span> <span class="p">{</span> <span class="n">collapsed</span><span class="o">:</span> <span class="n">not</span> <span class="n">collapsed</span> <span class="p">}</span>

<span class="c1">--------------------------------------------</span>
<span class="kr">module</span> <span class="nn">Parent</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">CollapsiblePanel</span> <span class="k">as</span> <span class="n">CP</span>

<span class="kr">type</span> <span class="kt">State</span> <span class="o">=</span>
  <span class="p">{</span> <span class="o">...</span>
  <span class="p">,</span> <span class="n">panel1</span> <span class="o">::</span> <span class="kt">CP</span><span class="o">.</span><span class="kt">State</span>
  <span class="p">,</span> <span class="n">panel2</span> <span class="o">::</span> <span class="kt">CP</span><span class="o">.</span><span class="kt">State</span>
  <span class="p">}</span>

<span class="kr">data</span> <span class="kt">Message</span>
  <span class="o">=</span> <span class="o">...</span>
  <span class="o">|</span> <span class="kt">CP1Msg</span> <span class="kt">CP</span><span class="o">.</span><span class="kt">Message</span>
  <span class="o">|</span> <span class="kt">CP2Msg</span> <span class="kt">CP</span><span class="o">.</span><span class="kt">Message</span>

<span class="n">view</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Dispatch</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">view</span> <span class="o">=</span> <span class="o">...</span>
  <span class="p">,</span> <span class="kt">CP</span><span class="o">.</span><span class="n">view</span> <span class="p">{</span> <span class="n">title</span><span class="o">:</span> <span class="s">"Panel 1"</span><span class="p">,</span> <span class="n">content</span><span class="o">:</span> <span class="kt">H</span><span class="o">.</span><span class="n">text</span> <span class="s">"Content 1"</span> <span class="p">}</span> <span class="n">state</span><span class="o">.</span><span class="n">panel1</span> <span class="p">(</span><span class="n">dispatch</span> <span class="o">&lt;&lt;&lt;</span> <span class="kt">CP1Msg</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="p">,</span> <span class="kt">CP</span><span class="o">.</span><span class="n">view</span> <span class="p">{</span> <span class="n">title</span><span class="o">:</span> <span class="s">"Panel 2"</span><span class="p">,</span> <span class="n">content</span><span class="o">:</span> <span class="kt">H</span><span class="o">.</span><span class="n">text</span> <span class="s">"Content 2"</span> <span class="p">}</span> <span class="n">state</span><span class="o">.</span><span class="n">panel1</span> <span class="p">(</span><span class="n">dispatch</span> <span class="o">&lt;&lt;&lt;</span> <span class="kt">CP2Msg</span><span class="p">)</span>
  <span class="o">...</span>

<span class="n">update</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">Transition</span> <span class="kt">Message</span> <span class="kt">State</span>
<span class="o">...</span>
<span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">CP1Msg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span>
  <span class="kt">CP</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">panel1</span> <span class="n">m</span>
  <span class="o">#</span> <span class="n">bimap</span> <span class="kt">CP1Msg</span> <span class="n">state</span> <span class="p">{</span> <span class="n">panel1</span> <span class="o">=</span> <span class="kr">_</span> <span class="p">}</span>
<span class="n">update</span> <span class="n">state</span> <span class="p">(</span><span class="kt">CP2Msg</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span>
  <span class="kt">CP</span><span class="o">.</span><span class="n">update</span> <span class="n">state</span><span class="o">.</span><span class="n">panel2</span> <span class="n">m</span>
  <span class="o">#</span> <span class="n">bimap</span> <span class="kt">CP2Msg</span> <span class="n">state</span> <span class="p">{</span> <span class="n">panel2</span> <span class="o">=</span> <span class="kr">_</span> <span class="p">}</span>
<span class="o">...</span>
</code></pre></div></div> <p>Phew! That’s a lot of boilerplate! But more importantly, the boilerplate is not really needed here, logically speaking. We never look at any messages of the <code class="language-plaintext highlighter-rouge">CollapsiblePanel</code>, we never inspect its state, all we do is blindly “route” the <code class="language-plaintext highlighter-rouge">CollapsiblePanel</code>’s messages and state transitions. This is textbook accidental complexity.</p> <p>For cases like this, Elmish supports a different mode of composition - <code class="language-plaintext highlighter-rouge">wrapWithLocalState</code>. This function takes a parameter of type <code class="language-plaintext highlighter-rouge">args -&gt; ComponentDef</code> (for some generic type <code class="language-plaintext highlighter-rouge">args</code>) and returns a function <code class="language-plaintext highlighter-rouge">args -&gt; ReactElement</code>. Under the hood, the <code class="language-plaintext highlighter-rouge">ComponentDef</code> is instantiated as a <code class="language-plaintext highlighter-rouge">React</code> component with its own, internal message/update/transition loop, completely independent of the parent component. The parent component may then use the <code class="language-plaintext highlighter-rouge">args -&gt; ReactElement</code> function in their <code class="language-plaintext highlighter-rouge">view</code> and not worry about routing the child component’s state and messages.</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">CollapsiblePanel</span> <span class="kr">where</span>

<span class="n">render</span> <span class="o">::</span> <span class="p">{</span> <span class="n">title</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">content</span> <span class="o">::</span> <span class="kt">ReactElement</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">render</span> <span class="o">=</span>
  <span class="n">wrapWithLocalState</span> <span class="p">(</span><span class="kt">ComponentName</span> <span class="s">"CollapsiblePanel"</span><span class="p">)</span> <span class="nf">\</span><span class="n">args</span> <span class="o">-&gt;</span>
    <span class="p">{</span> <span class="n">init</span><span class="p">,</span> <span class="n">view</span><span class="o">:</span> <span class="n">view</span> <span class="n">args</span><span class="p">,</span> <span class="n">update</span> <span class="p">}</span>

<span class="o">...</span>

<span class="c1">---------------------------------------------</span>

<span class="kr">module</span> <span class="nn">Parent</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">CollapsiblePanel</span> <span class="k">as</span> <span class="n">CP</span>

<span class="kr">type</span> <span class="kt">State</span> <span class="o">=</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1">-- no mention of CP.State</span>

<span class="kr">data</span> <span class="kt">Message</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">-- no mention of CP.Message</span>

<span class="n">view</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Dispatch</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">ReactElement</span>
<span class="n">view</span> <span class="n">state</span> <span class="n">dispatch</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="p">,</span> <span class="kt">CP</span><span class="o">.</span><span class="n">render</span> <span class="p">{</span> <span class="n">title</span><span class="o">:</span> <span class="s">"Panel 1"</span><span class="p">,</span> <span class="n">content</span><span class="o">:</span> <span class="kt">H</span><span class="o">.</span><span class="n">text</span> <span class="s">"Content 1"</span> <span class="p">}</span>
  <span class="o">...</span>
  <span class="p">,</span> <span class="kt">CP</span><span class="o">.</span><span class="n">render</span> <span class="p">{</span> <span class="n">title</span><span class="o">:</span> <span class="s">"Panel 2"</span><span class="p">,</span> <span class="n">content</span><span class="o">:</span> <span class="kt">H</span><span class="o">.</span><span class="n">text</span> <span class="s">"Content 2"</span> <span class="p">}</span>
  <span class="o">...</span>

<span class="n">update</span> <span class="o">::</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Message</span> <span class="o">-&gt;</span> <span class="kt">Transition</span> <span class="kt">Message</span> <span class="kt">State</span>
<span class="n">update</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1">-- no mention of CP.update</span>
</code></pre></div></div> <p>In this example, the <code class="language-plaintext highlighter-rouge">args</code> type is <code class="language-plaintext highlighter-rouge">{ title :: String, content :: ReactElement }</code>. We pass a function <code class="language-plaintext highlighter-rouge">args -&gt; ComponentDef</code> to <code class="language-plaintext highlighter-rouge">wrapWithLocalState</code> and it returns us a function <code class="language-plaintext highlighter-rouge">args -&gt; ReactElement</code>, which we name <code class="language-plaintext highlighter-rouge">render</code> and then use in the <code class="language-plaintext highlighter-rouge">Parent</code> module.</p> <p class="callout"><strong>NOTE 1</strong>: the <code class="language-plaintext highlighter-rouge">ComponentName</code> parameter is unfortunately required due to how React works under the hood. For a detailed explanation, see <a href="https://pursuit.purescript.org/packages/purescript-elmish/0.5.8/docs/Elmish.Component#t:ComponentName">docs on Pursuit</a>.</p> <p class="callout"><strong>NOTE 2</strong>: the name <code class="language-plaintext highlighter-rouge">wrapWithLocalState</code> will probably be changed in the future. We do not like the name, but we were unable to come up with a better alternative so far.</p> <p>This mode of composition works best under these conditions:</p> <ol> <li>The “parent” component does not need access to state or messages of the “child” component.</li> <li>The “child” component’s state is trivial, not critical to the application. The underlying mechanism relies on React’s component-local state (i.e. the <code class="language-plaintext highlighter-rouge">this.state</code> property), which turns out to be not guaranteed from occasional unwarranted reset.</li> </ol> <h2 id="events-from-child-components"> <a href="#events-from-child-components" class="anchor-heading" aria-labelledby="events-from-child-components"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Events from child components </h2> <hr> <footer> <p class="text-small text-grey-dk-100 mb-0">Copyright &copy; 2018-2022 CollegeVine</p> </footer> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
