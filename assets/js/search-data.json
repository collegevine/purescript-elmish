{"0": {
    "doc": "Composition",
    "title": "Composition",
    "content": "In a real program, it is almost never enough to have all of the UI logic and visuals in one place. Almost always it is beneficial to split up the UI into smaller parts, usually located in separate modules, be it for clarity and maintainability or for reuse. This page describes different patterns of such decomposition supported by Elmish. | Partial view functions | Composing full-fledged components | Dedicated event loop | Events from child components | . ",
    "url": "/purescript-elmish/composition/",
    "relUrl": "/composition/"
  },"1": {
    "doc": "Composition",
    "title": "Partial view functions",
    "content": "The simplest way to split up a big UI is to extract some parts of its view function as separate functions, what in some contexts might be called “partial view”. For example, consider the bespoke counter UI: . type State = { count :: Int } data Message = Inc | Dec view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = H.div \"\" [ H.div \"\" $ \"The current count is: \" &lt;&gt; show state.count , button \"increase\" (dispatch Inc) , button \"decrease\" (dispatch Dec) ] button :: String -&gt; Effect Unit -&gt; ReactElement button text onClick = H.div \"\" [ H.text $ \"To \" &lt;&gt; text &lt;&gt; \" the count, click here: \" , H.button_ \"btn btn-primary\" { onClick } text ] . Here, we have extracted the visuals for “increase” and “decrease” buttons as a partial view function named button, which is then used twice in the main view function. NOTE: such “partial view” function doesn’t have to be just a visual. As seen in this example, it can produce messages as well. Often, especially with larger partial views, it’s beneficial to name their parameters by gathering them in a record: . view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = H.div \"\" [ H.div \"\" $ \"The current count is: \" &lt;&gt; show state.count , button { text: \"increase\", onClick: dispatch Inc } , button { text: \"decrease\", onClick: dispatch Dec } ] button :: { text :: String, onClick :: Effect Unit } -&gt; ReactElement button { text, onClick } = H.div \"\" [ H.text $ \"To \" &lt;&gt; text &lt;&gt; \" the count, click here: \" , H.button_ \"btn btn-primary\" { onClick } text ] . ",
    "url": "/purescript-elmish/composition/#partial-view-functions",
    "relUrl": "/composition/#partial-view-functions"
  },"2": {
    "doc": "Composition",
    "title": "Composing full-fledged components",
    "content": "Partial view functions are great, because they’re simple, but sometimes it does make sense to package away a whole piece of complex UI logic - either for reuse or just for code organization. This setup is usually referred to as “child components”. For example, let’s say we wanted to create a UI consisting of two such counters as shown above: . To do this, we would aggregate the two counters’ states, route their messages and state transitions, and compose their views: . import Counter as Counter -- Aggregate child components' states type State = { left :: Counter.State , right :: Counter.State } -- Aggregate child components' messages data Message = LeftMsg Counter.Message | RightMsg Counter.Message view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = H.div \"row\" [ H.div \"col-6\" [ H.h3 \"\" \"Left counter\" , Counter.view state.left (dispatch &lt;&lt;&lt; LeftMsg) ] , H.div \"col-6\" [ H.h3 \"\" \"Right counter\" , Counter.view state.right (dispatch &lt;&lt;&lt; RightMsg) ] ] . Note how we’re calling Counter.view twice, but passing it different states (left and right) and different Dispatch functions - one wrapping Counter’s messages in LeftMsg and the other wrapping them in RightMsg. So far so good. But what about the update function? . Since Transition is a pair of state + effects (see Transition: Under the Hood), we could do it the straightforward way: . | Call Counter.update | Unwrap the resulting Transition to obtain the new counter state and any effects. | Plug the new counter state into the aggregate State | Modify the effects to wrap all messages they produce in LeftMsg (or RightMsg). | Reconstruct Transition out of the new aggregate State and the modified effects. | . This is what your typical Elm program does, and it would look something like this: . update state (LeftMsg m) = let Transition s effs = Counter.update state.left m state' = state { left = s } effs' = map LeftMsg &lt;$&gt; effs in Transition state' effs' . This is straightforward, but in practice this becomes very tedious very fast. So instead, we could use the fact that Transition is a monad (to thread the state via bind) as well as a Bifunctor (to wrap the effect messages via lmap). This would look somewhat like this: . update state (LeftMsg m) = do s' &lt;- lmap LeftMsg $ Counter.update state.left m pure state { left = s' } . NOTE: See the Transition page for a detailed description of how the do notation works with Transition . Or even better: for a straightforward mapping like this, without any extra processing, we could use just the Bifunctor aspect of Transition and map both messages and state via bimap: . update state (LeftMsg m) = bimap LeftMsg state { left = _ } $ Counter.update state.left m . NOTE: This syntax works because of how PureScript’s record updates are parsed. The expression state { left = _ } is a single term, equivalent to a function \\x -&gt; state { left = x } . Armed with this knowledge, we can now write the full update function of the composed component: . update :: State -&gt; Message -&gt; Transition Message State update state (LeftMsg m) = bimap LeftMsg state { left = _ } $ Counter.update state.left m update state (RightMsg m) = bimap RightMsg state { right = _ } $ Counter.update state.right m . This mode of composition is sure less tedious than in Elm, but still heavy compared to the partial view functions. Use with care. ",
    "url": "/purescript-elmish/composition/#composing-full-fledged-components",
    "relUrl": "/composition/#composing-full-fledged-components"
  },"3": {
    "doc": "Composition",
    "title": "Dedicated event loop",
    "content": "Aggregating child component’s state and message into those of the parent component is the standard composition procedure in The Elm Architecture. Sometimes, however, it turns out to be very inconvenient for no reason. Say we wanted to display two areas of our UI in “collapsible panels” - i.e. a header with a button that shows or hides contents: . module CollapsiblePanel where type State = { collapsed :: Boolean } data Message = Toggle view :: { title :: String, content :: ReactElement } -&gt; State -&gt; Dispatch Message -&gt; ReactElement view { title, content } state dispatch = H.div \"\" [ H.div_ \"bg-light\" { onClick: dispatch Toggle } title , if collapsed then H.empty else H.div \"\" content ] update :: State -&gt; Message -&gt; Transition Message State update { collapsed } Toggle = { collapsed: not collapsed } -------------------------------------------- module Parent where import CollapsiblePanel as CP type State = { ... , panel1 :: CP.State , panel2 :: CP.State } data Message = ... | CP1Msg CP.Message | CP2Msg CP.Message view :: State -&gt; Dispatch Message -&gt; ReactElement view = ... , CP.view { title: \"Panel 1\", content: H.text \"Content 1\" } state.panel1 (dispatch &lt;&lt;&lt; CP1Msg) ... , CP.view { title: \"Panel 2\", content: H.text \"Content 2\" } state.panel1 (dispatch &lt;&lt;&lt; CP2Msg) ... update :: State -&gt; Message -&gt; Transition Message State ... update state (CP1Msg m) = CP.update state.panel1 m # bimap CP1Msg state { panel1 = _ } update state (CP2Msg m) = CP.update state.panel2 m # bimap CP2Msg state { panel2 = _ } ... Phew! That’s a lot of boilerplate! But more importantly, the boilerplate is not really needed here, logically speaking. We never look at any messages of the CollapsiblePanel, we never inspect its state, all we do is blindly “route” the CollapsiblePanel’s messages and state transitions. This is textbook accidental complexity. For cases like this, Elmish supports a different mode of composition - wrapWithLocalState. This function takes a parameter of type args -&gt; ComponentDef (for some generic type args) and returns a function args -&gt; ReactElement. Under the hood, the ComponentDef is instantiated as a React component with its own, internal message/update/transition loop, completely independent of the parent component. The parent component may then use the args -&gt; ReactElement function in their view and not worry about routing the child component’s state and messages. module CollapsiblePanel where render :: { title :: String, content :: ReactElement } -&gt; ReactElement render = wrapWithLocalState (ComponentName \"CollapsiblePanel\") \\args -&gt; { init, view: view args, update } ... --------------------------------------------- module Parent where import CollapsiblePanel as CP type State = { ... } -- no mention of CP.State data Message = ... -- no mention of CP.Message view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = ... , CP.render { title: \"Panel 1\", content: H.text \"Content 1\" } ... , CP.render { title: \"Panel 2\", content: H.text \"Content 2\" } ... update :: State -&gt; Message -&gt; Transition Message State update = ... -- no mention of CP.update . In this example, the args type is { title :: String, content :: ReactElement }. We pass a function args -&gt; ComponentDef to wrapWithLocalState and it returns us a function args -&gt; ReactElement, which we name render and then use in the Parent module. NOTE 1: the ComponentName parameter is unfortunately required due to how React works under the hood. For a detailed explanation, see docs on Pursuit. NOTE 2: the name wrapWithLocalState will probably be changed in the future. We do not like the name, but we were unable to come up with a better alternative so far. This mode of composition works best under these conditions: . | The “parent” component does not need access to state or messages of the “child” component. | The “child” component’s state is trivial, not critical to the application. The underlying mechanism relies on React’s component-local state (i.e. the this.state property), which turns out to be not guaranteed from occasional unwarranted reset. | . ",
    "url": "/purescript-elmish/composition/#dedicated-event-loop",
    "relUrl": "/composition/#dedicated-event-loop"
  },"4": {
    "doc": "Composition",
    "title": "Events from child components",
    "content": " ",
    "url": "/purescript-elmish/composition/#events-from-child-components",
    "relUrl": "/composition/#events-from-child-components"
  },"5": {
    "doc": "Rendering HTML",
    "title": "Rendering HTML",
    "content": ". | HTML elements | HTML attributes, aka Props | Content | Atomic CSS support | Event handlers | Lower-level event access | . ",
    "url": "/purescript-elmish/dom-elements/",
    "relUrl": "/dom-elements/"
  },"6": {
    "doc": "Rendering HTML",
    "title": "HTML elements",
    "content": "Elmish itself is agnostic of how views are actually rendered. It requires you to produce a ReactElement value, and it doesn’t care much how you do it. In fact, in the very early days, all rendering was done in JavaScript, and the resulting ReactElement values were FFIed back to PureScript. But of course it has to be done somehow, and the primary way it is done these days is with functions provided by the purescript-elmish-html library. The library provides a wide array of functions, one for every HTML element. The elements can be combined in a tree, much like one would do in regular HTML or in React+JSX. For example: . import Elmish.HTML as H view = H.div {} [ H.h1 {} \"Welcome!\" , H.p {} [ H.text \"This is just an example to demonstrate usage of the \" , H.a { href: \"https://github.com/collegevine/purescript-elmish-html\" } \"elmish-html\" , H.text \" library\" ] , H.img { src: \"/img/welcome.png\", width: 100, height: 200 } , H.button { onClick: dispatch Login } \"Click here to login\" ] . Most functions have two parameters - HTML attributes and content. ",
    "url": "/purescript-elmish/dom-elements/#html-elements",
    "relUrl": "/dom-elements/#html-elements"
  },"7": {
    "doc": "Rendering HTML",
    "title": "HTML attributes, aka Props",
    "content": "Every element may have zero or more attributes, which are passed as the first parameter, typed as a record. The types are constructed so that you can pass only a subset of all available attributes, not all of that (imagine how inconvenient that would be!) . The attribute names and types are exactly the same as their namesakes in React. In fact, the record of attributes is just passed straight to react, without any further processing. This reduces complexity and saves some performance, but unfortunately creates some inconvenience with events. ",
    "url": "/purescript-elmish/dom-elements/#html-attributes-aka-props",
    "relUrl": "/dom-elements/#html-attributes-aka-props"
  },"8": {
    "doc": "Rendering HTML",
    "title": "Content",
    "content": "The “content”, or “inside” of the element, can be one of: . | Another element | An array of elements | A string | . Some elements, such as img, do not have a second parameter, because in HTML they are not allowed to have content. NOTE: Since PureScript doesn’t allow arrays of mixed types, strings need to be wrapped in H.text when they are mixed with other elements, as demonstrated in the example above. ",
    "url": "/purescript-elmish/dom-elements/#content",
    "relUrl": "/dom-elements/#content"
  },"9": {
    "doc": "Rendering HTML",
    "title": "Atomic CSS support",
    "content": "If you prefer Bootstrap for styling (or another atomic CSS library), you could use it exactly the same way you would in React - by passing in a className prop. For example: . import Elmish.HTML as H view = H.div { className: \"border bg-light\" } [ H.p { className: \"mt-4 mb-3\" } \"Click this button:\" , H.button { className: \"btn btn-primary px-4\", onClick: dispatch ButtonClicked } \"Click me!\" ] . But we found that this quickly becomes quite inconvenient. So the elmish-html library provides an alternative module Elmish.HTML.Styled, which exports alternative versions of all elements taking the CSS class as first parameter: . import Elmish.HTML.Styled as H view = H.div \"border bg-light\" [ H.p \"mt-4 mb-3\" \"Click this button:\" , H.button \"btn btn-primary px-4\" \"Click me!\" ] . This scheme is somewhat inspired by the HAML templates, which for the example above would look something like this: . %div.border.bg-light %p.mt-4.mb-3 Click this button: %button.btn.btn-primary.px-4 Click me! . We find this much more convenient in practice, but of course it’s stricly optional. And you can also mix and match as you wish. Q: ok, but what if I need to pass other props, besides className? . To facilitate this, every element in Elmish.HTML.Styled has two versions - e.g. button and button_ (note the underscore). The former just takes CSS class as parameter, while the latter also takes other props as a record: . import Elmish.HTML.Styled as H view = H.div \"border bg-light\" [ H.p \"mt-4 mb-3\" \"Click this button:\" , H.button_ \"btn btn-primary px-4\" { onClick: foo } \"Click me!\" ] . This scheme is used for all elements, even those that don’t make sense without props (such as img or input), just for consistency and predictability. ",
    "url": "/purescript-elmish/dom-elements/#atomic-css-support",
    "relUrl": "/dom-elements/#atomic-css-support"
  },"10": {
    "doc": "Rendering HTML",
    "title": "Event handlers",
    "content": "NOTE: the way DOM events are modeled in the elmish-html library is a work in progress. The API is functional, but not very ergonomic. It is subject to change in the future. Since the props record is passed directly to React, and in React event handlers are modeled as functions taking SyntheticEvent, the elmish-html library simply directly maps that to PureScript: . onChange :: EffectFn1 Foreign Unit . We represent the SyntheticEvent argument as Foreign in order to avoid taking purescript-web-events (or any other similar library) as a dependency. Our experience shows that well-typed Event functions are not actually useful in practice. A notable exception is the onClick event, which is represented as just: . onClick :: Effect Unit . We chose to ignore the argument in this particular case because it’s very rarely useful in practice and most of the time ends up being ignored. Q: but if the event is just Foreign, how do I get at its properties? . To do this, Elmish provides a universal way to access JavaScript data in a safe way: readForeign. Given expected shape of the Foreign object, this function can verify that the object indeed has that shape, and return it correctly typed: . view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = ... H.input_ { type: \"text\" , value: state.inputValue , onChange: mkEffectFn1 \\foreignEvent -&gt; do let event :: Maybe { target :: { value :: String } } = readForeign foreignEvent case event of Just e -&gt; dispatch $ InputChanged e.target.value Noting -&gt; pure unit -- Event did not have expected fields for some reason } ... Here we are specifying the expected type of event variable, which is readForeign’s result, and if it ends up as Just, we can be sure the event has the specified shape. Then we can just access its properties - e.target.value. But of course, this is a lot of boilerplate: the mkEffectFn1 call, the case expression - all of that would be exactly the same for every event handler. So Elmish provides two operators for convenience: &lt;| and &lt;?| . The &lt;| operator takes care of the EffectFn1 business. It takes the dispatch function on the left and an event -&gt; message function on the right, and takes care of piping through from one to the other: . , onChange: dispatch &lt;| \\event -&gt; InputChanged \"foo\" . The &lt;?| operator does basically the same thing, except the function it takes on the right is event -&gt; Maybe message: . , onChange: dispatch &lt;?| \\event -&gt; do e :: { target :: { value :: _ } } &lt;- readForeign event Just $ InputChanged e.target.value . NOTE: Here we’re taking advantage of “type wildcards” - replacing String with an underscore means asking PureScript to infer it from context, which it can do from the type of InputChanged’s argument. Sadly, there seems to be no way to infer the whole shape of the nested records. In real applications that work a lot with textboxes, we usually end up defining a special-purpose function for accessing event.target.value: . eventTargetValue :: Foreign -&gt; Maybe String eventTargetValue f = e :: { target :: { value :: _ } } &lt;- readForeign f Just e.target.value ... , onChange: dispatch &lt;?| \\e -&gt; InputChanged &lt;$&gt; eventTargetValue e ... Though this function is not (yet?) part of the library. ",
    "url": "/purescript-elmish/dom-elements/#event-handlers",
    "relUrl": "/dom-elements/#event-handlers"
  },"11": {
    "doc": "Rendering HTML",
    "title": "Lower-level event access",
    "content": "In extreme cases it may be necessary to access the React SyntheticEvent after all, even when it’s not part of the event’s type signature (such as onClick), for example to preventDefault or stopPropagation. For these cases there is currently no good solution, and we’re simply resorting to unsafeCoerceing our way through it: ... , onClick: unsafeCoerce $ mkEffectFn1 \\e -&gt; do stopPropagation e dispatch ButtonClicked ... If you find yourself in need to do this, use care and make sure you understand underlying JavaScript types. ",
    "url": "/purescript-elmish/dom-elements/#lower-level-event-access",
    "relUrl": "/dom-elements/#lower-level-event-access"
  },"12": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": ". | Requisite tools | Initialize an empty project | Minimal SPA scaffolding | Hello World | Interaction | More complex events | Effects | . ",
    "url": "/purescript-elmish/getting-started/",
    "relUrl": "/getting-started/"
  },"13": {
    "doc": "Getting Started",
    "title": "Requisite tools",
    "content": "Elmish is a PureScript library, and PureScript works with NodeJS, and that’s pretty much the only tool you’ll need to install upfront. This tutorial assumes a basic familiarity with PureScript language as such, as well as Node and its associated tooling. ",
    "url": "/purescript-elmish/getting-started/#requisite-tools",
    "relUrl": "/getting-started/#requisite-tools"
  },"14": {
    "doc": "Getting Started",
    "title": "Initialize an empty project",
    "content": ". | Create an empty directory, run npm init to initialize a new Node project. The result should be a lone package.json file. | Run npm install --save purescript spago react react-dom esbuild to install: . | purescript - the PureScript compiler. | spago - the PureScript package manager. | react and react-dom - the React library, on which Elmish is based. | esbuild - the fastest JavaScript bundler currently available. | . | Run npx spago init to initialize a new PureScript project in the directory. This should create a bit of scaffolding, including a couple of *.dhall files and an src directory with Main.purs in it. | Run npx spago install elmish elmish-html to install the Elmish library and its companion elmish-html. | . ",
    "url": "/purescript-elmish/getting-started/#initialize-an-empty-project",
    "relUrl": "/getting-started/#initialize-an-empty-project"
  },"15": {
    "doc": "Getting Started",
    "title": "Minimal SPA scaffolding",
    "content": ". | Using your favourite text editor, create a file named index.html and put the following code in it: . &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\"&gt; &lt;div id=\"app\"&gt;The UI is not here yet&lt;/div&gt; &lt;script src=\"output/index.js\"&gt;&lt;/script&gt; &lt;script&gt;window.Main.main()&lt;/script&gt; . The second line is the container for the application to render itself in. The third line references the JavaScript bundle (result of your code compilation). The fourth line invokes the PureScript entry point function. NOTE: we’re using Bootstrap for styling. Looks better that way. | Open package.json, find the scripts section in it, and add the following line: . \"start\": \"spago build &amp;&amp; esbuild ./output/Main/index.js --bundle --serve --servedir=. --outfile=output/index.js --global-name=Main\" . This command first builds your project (via spago build) and then starts the esbuild bundler to bundle the compilation results and simultaneously serve them with a built-in web server. | To verify, run npm start. This should, after a few seconds, display something along the lines of: . Local: http://127.0.0.1:8000/ . Open that address in a browser. You should see text “The UI is not here yet”. If you don’t see that, something is wrong with the setup so far. | . ",
    "url": "/purescript-elmish/getting-started/#minimal-spa-scaffolding",
    "relUrl": "/getting-started/#minimal-spa-scaffolding"
  },"16": {
    "doc": "Getting Started",
    "title": "Hello World",
    "content": "To start your Elmish UI, first you’ll need to define the five elements, as explained in the overview, - State, Message, init, update, and view. We’re going to put all of this in Main.purs: . -- Nothing happens in our UI so far, so there are no messages data Message -- The UI is just static text, so there is no initial state type State = Unit -- Since there is no state, there is nothing to initialize init :: Transition Message State init = pure unit -- Since there are no messages, the `update` function is also trivial update :: State -&gt; Message -&gt; Transition Message State update _ _ = pure unit view :: State -&gt; Dispatch Message -&gt; ReactElement view _ _ = H.div \"p-4\" [ H.text \"Hello, \" , H.strong \"\" \"World!\" ] . NOTE: the H.div function takes a CSS class as the first parameter, and so does the H.strong function. This style works very well with Bootstrap (where most elements have a class), but it’s not the only choice. See Rendering HTML for more. To make that compile, you’ll need the following imports: . import Elmish (Transition, Dispatch, ReactElement) import Elmish.HTML.Styled as H -- This is more convenient to import qualified import Elmish.Boot (defaultMain) -- We'll need this in a moment . Now all that remains is to hook that up to the entry point. To do that, put the following in main: . main :: Effect Unit main = defaultMain { def: { init, view, update }, elementId: \"app\" } . Now save and refresh your browser. Assuming you still have npm start running, you should see “Hello, World!” on the screen. ",
    "url": "/purescript-elmish/getting-started/#hello-world",
    "relUrl": "/getting-started/#hello-world"
  },"17": {
    "doc": "Getting Started",
    "title": "Interaction",
    "content": "Now let’s add some interaction. We’ll do the simplest kind for now: a button click. To do that, we’ll need a message to describe the click: . - data Message + data Message = ButtonClicked . And in order for the button to have a visible effect, we’ll add some state for it to change: . - type State = Unit + type State = { word :: String } . The init function should provide initial state of the right type: . init :: Transition Message State - init = pure unit + init = pure { word: \"World\" } . And the update function should react to the button click by updating the state: . update :: State -&gt; Message -&gt; Transition Message State - update _ _ = pure unit + update state ButtonClicked = pure state { word = \"Elmish\" } . And finally, the view function should add a button: . view :: State -&gt; Dispatch Message -&gt; ReactElement - view _ _ = + view state dispatch = H.div \"p-4\" + [ H.div \"\" [ H.text \"Hello, \" - , H.strong \"\" \"World!\" + , H.strong \"\" state.word , H.text \"! \" ] + , H.button_ \"btn btn-primary mt-3\" { onClick: dispatch ButtonClicked } \"Click me!\" ] . If you refresh your browser now, you should see this: . NOTE: we just introduced the first prop (onClick) passed to a DOM element (button). For a more detailed discussion of props, see Rendering HTML. ",
    "url": "/purescript-elmish/getting-started/#interaction",
    "relUrl": "/getting-started/#interaction"
  },"18": {
    "doc": "Getting Started",
    "title": "More complex events",
    "content": "The onClick event we used above is nice, but it’s a limited example of an event: it doesn’t have any parameters, but most events do. The elmish-html library models all events of standard DOM elements as an effectful function (i.e. EffectFn1) taking a Foreign parameter, even though the underlying value is actually React Synthetic Event. Mostly this is because it’s still a work in progress. Events may get a more interesting type in the future. But for now, the idea is to get the Foreign parameter and extract interesting values from it via readForeign, which is a standard Elmish mechanism for dealing with JS values of unknown nature (see here for more on it). To illustrate this, let’s add a textbox to our application to let the user edit the text: . - data Message = ButtonClicked + data Message + = ButtonClicked + | WordChanged String type State = { word :: String } init :: Transition Message State init = pure { word: \"World\" } update :: State -&gt; Message -&gt; Transition Message State update state ButtonClicked = pure state { word = \"Elmish\" } + update state (WordChanged s) = pure state { word = s } view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = H.div \"p-4\" + [ H.input_ \"d-block\" + { type: \"text\" + , value: state.word + , onChange: mkEffectFn1 \\f -&gt; do + let parsed = readForeign f :: Maybe { target :: { value :: String } } + case parsed of + Nothing -&gt; pure unit + Just e -&gt; dispatch $ WordChanged e.target.value + } , H.div \"mt-3\" [ H.text \"Hello, \" , H.strong \"\" state.word , H.text \"! \" ] , H.button_ \"btn btn-primary mt-3\" { onClick: dispatch ButtonClicked } \"Click me!\" ] . But of course, this is a bit too much ceremony, so there is a special operator &lt;?| that takes care of the case and the mkEffectFn1 parts for us: . - import Elmish (Dispatch, ReactElement, Transition) + import Elmish (Dispatch, ReactElement, Transition, (&lt;?|)) ... , onChange: dispatch &lt;?| \\f -&gt; (readForeign f :: _ { target :: { value :: String } }) &lt;#&gt; \\e -&gt; WordChanged e.target.value . Unfortunately, we still have to specify the shape of the record. Otherwise the compiler won’t be able to tell what we expect to find. For frequently used patterns like this, it’s often benefitial to extract them as a function: . eventTargetValue :: Foreign -&gt; Maybe String eventTargetValue f = (readForeign f :: _ { target :: { value :: String } }) &lt;#&gt; _.target.value ... , onChange: dispatch &lt;?| \\f -&gt; WordChanged &lt;$&gt; eventTargetValue f . ",
    "url": "/purescript-elmish/getting-started/#more-complex-events",
    "relUrl": "/getting-started/#more-complex-events"
  },"19": {
    "doc": "Getting Started",
    "title": "Effects",
    "content": "It is a rare UI that comes without effects - something that happens outside the UI, be it local storage, timers, communication with a server, and so on. In Elmish effects are defined by the update function. Its return type Transition Message State encodes the new (“updated”) state and zero or more effects that should happen as a result of this state transition (hence the name Transition). Let’s add a simple effect as a result of our ButtonClicked message: output a line to the console. + import Effect.Class.Console (log) - import Elmish (Transition, Dispatch, ReactElement, (&lt;?|)) + import Elmish (Transition, Dispatch, ReactElement, forkVoid, (&lt;?|)) ... update :: State -&gt; Message -&gt; Transition Message State - update state ButtonClicked = pure state { word = \"Elmish\" } + update state ButtonClicked = do + forkVoid $ log \"Button clicked\" + pure state { word = \"Elmish\" } update state (WordChanged s) = pure state { word = s } . If you refresh your browser now and open console in the developer tools, you should see something like this: . The forkVoid function adds an effect to the current state transition. The “void” suffix means that the effect does not produce any more messages. But most effects do eventually produce a message. Think of a server interaction: in most cases the server response has to affect the UI somehow. To achieve this, use the function fork (without the “void” suffix). Server communication is a bit too complicated for this tutorial, so let’s add a timer instead: . + import Effect.Aff (Milliseconds(..), delay) import Effect.Class.Console (log) - import Elmish (Dispatch, ReactElement, Transition, forkVoid, (&lt;?|)) + import Elmish (Dispatch, ReactElement, Transition, fork, forkVoid, (&lt;?|)) ... data Message = ButtonClicked | WordChanged String + | TimeoutElapsed ... update :: State -&gt; Message -&gt; Transition Message State update state ButtonClicked = do forkVoid $ log \"Button clicked\" + fork do + delay $ Milliseconds 1000.0 + pure TimeoutElapsed pure state { word = \"Elmish\" } update state (WordChanged s) = pure state { word = s } + update state TimeoutElapsed = + pure state { word = state.word &lt;&gt; \" after a while\" } . NOTE: there are many more ways to work with effects. For more information please see the page about state transitions . ",
    "url": "/purescript-elmish/getting-started/#effects",
    "relUrl": "/getting-started/#effects"
  },"20": {
    "doc": "Intro",
    "title": "Intro",
    "content": "Elmish is a PureScript UI library that (loosely) follows The Elm Architecture, implemented as a thin layer on top of React. Unlike Elm itself, Elmish allows arbitrary side-effects, including running them in a custom monad. ",
    "url": "/purescript-elmish/",
    "relUrl": "/"
  },"21": {
    "doc": "Intro",
    "title": "The Elm Architecture",
    "content": "In short, the idea is that your UI consists of: . | “state” - a data structure that describes what the UI looks like and what it can do. | “view” - a function that can take the “state” and produce some HTML from it. | “message” - a description of something happening in the UI, such as a button click or a timer firing. There is generally a finite set of possible messages for a given UI component. | “update” - a function that can take the current “state” and a “message”, and figure out what the new state should be as a result of receiving that message. | “init” - a way to create initial “state”. | . ",
    "url": "/purescript-elmish/#the-elm-architecture",
    "relUrl": "/#the-elm-architecture"
  },"22": {
    "doc": "Intro",
    "title": "A small, yet complete example",
    "content": "Some more involved examples can be found in the elmish-examples repository. This example is just to give the overall feel of what an Elmish UI generally looks like, and to tie together the above bullet-list definition. For more explanations and tutorials, see Getting Started. type Cell = { x :: Int, y :: Int } type State = Array Cell data Message = Up | Down | Left | Right bounds :: Cell bounds = { x: 20, y: 20 } init :: Transition Aff Message State init = pure $ (5..10) &lt;#&gt; \\idx -&gt; { x: idx, y: 10 } view :: State -&gt; Dispatch Message -&gt; ReactElement view state dispatch = H.div \"m-4\" [ H.div \"d-flex flex-column mb-3\" $ 0..(bounds.y-1) &lt;#&gt; \\row -&gt; H.div \"d-flex\" $ 0..(bounds.x-1) &lt;#&gt; \\col -&gt; H.div_ \"border border-dark p-2 m-1\" { style: H.css { background: bgColor col row } } \"\" , H.button_ \"btn btn-outline-primary ml-5 mr-2\" { onClick: dispatch Left } \"⬅️\" , H.button_ \"btn btn-outline-primary mr-2\" { onClick: dispatch Down } \"⬇️\" , H.button_ \"btn btn-outline-primary mr-2\" { onClick: dispatch Up } \"⬆️\" , H.button_ \"btn btn-outline-primary mr-2\" { onClick: dispatch Right } \"➡️\" ] where bgColor x y = case findIndex (eq { x, y }) state of Just idx -&gt; \"rgb(255, \" &lt;&gt; show (idx*45) &lt;&gt; \", 255)\" Nothing -&gt; \"white\" update :: State -&gt; Message -&gt; Transition Aff Message State update state msg = case msg of Up -&gt; move 0 (-1) Down -&gt; move 0 1 Left -&gt; move (-1) 0 Right -&gt; move 1 0 where move dx dy = case uncons state of Just { head } -&gt; do pure $ { x: head.x + dx, y: head.y + dy } : take (length state - 1) state Nothing -&gt; pure state . ",
    "url": "/purescript-elmish/#a-small-yet-complete-example",
    "relUrl": "/#a-small-yet-complete-example"
  },"23": {
    "doc": "Using React components",
    "title": "Using React components",
    "content": "Under construction. This page is unfinished. Many headings just have some bullet points sketching the main points that should be discussed. ",
    "url": "/purescript-elmish/react-ffi/",
    "relUrl": "/react-ffi/"
  },"24": {
    "doc": "Consuming JS data",
    "title": "Consuming JS data",
    "content": "Elmish is explicitly built on top of React and does not try to hide this fact behind a higher-level abstraction. Elmish embraces React. This lets us leverage the ecosystem, but also comes with certain difficulties as we’re forced to pass data to and from JavaScript code, and JavaScript code can be very liberal with data shapes. To make this data exchange saner and safer, Elmish provides a mechanism for data shape validation. | Taking JS data as input | Primitive types only | Passing data out | . ",
    "url": "/purescript-elmish/read-foreign/#consuming-js-data",
    "relUrl": "/read-foreign/#consuming-js-data"
  },"25": {
    "doc": "Consuming JS data",
    "title": "Taking JS data as input",
    "content": "If you’re looking at a data structure you just got from some JavaScript code, represented as a Foreign of course (can’t make assumptions, can we?), you can use the readForeign function to see if it has the right shape: . import Elmish.Foreign (readForeign) type MyData = { x :: { y :: Int }, z :: String } callMeFromJavaScript :: Foreign -&gt; String callMeFromJavaScript f = case readForeign f :: Maybe MyData of Nothing -&gt; \"Incoming data has the wrong shape\" Just a -&gt; \"Got the right data: x.y = \" &lt;&gt; show a.x.y &lt;&gt; \", z = \" &lt;&gt; a.z . Try it live . readForeign will return Nothing if the value doesn’t conform to the expected type, or Just a if it does, where a has the right type. NOTE: readForeign doesn’t actually convert the data structure. It only traverses it and makes sure that it has the right shape. This strategy turns out to much faster than parsing with something like purescript-argonaut, which lets us use it at all kinds of ingest boundaries, such as: . | Network API calls | Top-level entry points | Event handlers | etc. | . The example above uses the readForeign function, which returns a Maybe, but it also has a big brother readForeign' (note the prime), which returns an Either, providing an error message about what exactly is incorrect with the data: . callMeFromJavaScript :: Foreign -&gt; String callMeFromJavaScript f = case readForeign' f :: _ _ MyData of Left err -&gt; \"Oops: \" &lt;&gt; err Right a -&gt; \"Got the right data: x.y = \" &lt;&gt; show a.x.y &lt;&gt; \", z = \" &lt;&gt; a.z . Try it live . NOTE: We’re using type wildcards (underscores) so we don’t have to write Either String every time. ",
    "url": "/purescript-elmish/read-foreign/#taking-js-data-as-input",
    "relUrl": "/read-foreign/#taking-js-data-as-input"
  },"26": {
    "doc": "Consuming JS data",
    "title": "Primitive types only",
    "content": "The fact that readForeign doesn’t actually convert data has an important corollary: the data structure cannot contain any types that do not have straightforward JavaScript representation. For example, String is fine, and so it Array String, but Maybe String is not allowed, and neither is Either String Int. This is by design. The idea behind this mechanism is to enable type safety, which is not the same as data marshalling, although the two are frequently conflated. In any given situation marshalling may or may not be appropriate. If it is, it can be done separately, in combination with readForeign or instead of it. If no marshalling is required, readForeign is much smaller and more performant. ",
    "url": "/purescript-elmish/read-foreign/#primitive-types-only",
    "relUrl": "/read-foreign/#primitive-types-only"
  },"27": {
    "doc": "Consuming JS data",
    "title": "Passing data out",
    "content": ". | Want to protect from accidentally passing PureScript data | So have a type-class | Compile-time only, zero-cost runtime | . ",
    "url": "/purescript-elmish/read-foreign/#passing-data-out",
    "relUrl": "/read-foreign/#passing-data-out"
  },"28": {
    "doc": "Consuming JS data",
    "title": "Consuming JS data",
    "content": "Under construction. This page is unfinished. Many headings just have some bullet points sketching the main points that should be discussed. ",
    "url": "/purescript-elmish/read-foreign/",
    "relUrl": "/read-foreign/"
  },"29": {
    "doc": "State Transitions",
    "title": "State Transitions",
    "content": ". | Basics | State | Effects | Under the hood | . ",
    "url": "/purescript-elmish/transition/",
    "relUrl": "/transition/"
  },"30": {
    "doc": "State Transitions",
    "title": "Basics",
    "content": "The update function (see Intro) describes a UI state transition in response to a particular message. This transition consists of two components: . | the new state of the UI | zero or more effects | . Effects are monadic computations (usually in Effect or Aff), which do something useful, such as communicating with the server, accessing local storage, system clock, and so on, and as a result produce a new message, which then triggers another state transition, completing the loop. A transition has type Transition message state, with the state type parameter indicating what type of state the transition describes, and the message parameter indicating what type of messages the effects in the transition would produce. ",
    "url": "/purescript-elmish/transition/#basics",
    "relUrl": "/transition/#basics"
  },"31": {
    "doc": "State Transitions",
    "title": "State",
    "content": "The way to define the “new state” part of a transition is via pure (which works because the Transition type is a monad). For example, the bespoke counter UI might look something like this: . type State = { count :: Int } data Message = Inc | Dec update :: State -&gt; Message -&gt; Transition Message State update state Inc = pure $ state { count = state.count + 1 } update state Dec = pure $ state { count = state.count - 1 } . Because Transition is a monad, the update function has access to all the monadic goodies, such as the do notation, composition, traversals, etc. For example: . update :: State -&gt; Message -&gt; Transition Message State update state Inc = modifyCount state 1 update state Dec = modifyCount state (-1) modifyCount :: State -&gt; Int -&gt; Transition Message State modifyCount state delta = do let newCount = state.count + delta newState = state { count = newCount } pure newState . ",
    "url": "/purescript-elmish/transition/#state",
    "relUrl": "/transition/#state"
  },"32": {
    "doc": "State Transitions",
    "title": "Effects",
    "content": "The high-level, most convenient way to add an effect to a transition is via the fork function. For example, if we wanted to make counter increments happen after a delay, we might do something like this: . data Message = Inc | Dec | StartInc update :: State -&gt; Message -&gt; Transition Message State update state Inc = pure $ state { count = state.count + 1 } update state Dec = pure $ state { count = state.count - 1 } update state StartInc = do fork do delay (Milliseconds 1000.0) pure Inc pure state . The block passed to the fork function is an Aff computation, which waits one second and then returns the Inc message. This message will then be fed right back into the update function, causing a state transition to increase the count. NOTE: even though it contains a do block, the update function itself runs no actual effects. It is completely pure. The update function only “prepares” effectful computations (by calling fork), gathers them in a bunch, and returns them to the Elmish core, packaged together with the new state value in a Transition data structure. It is only after the update function has finished evaluating that the Elmish core will execute any effects it returned. Sometimes it happens so that the computation may or may not produce a message depending on some external reasons. In this case, the forkMaybe function is handy. It takes an Aff (Maybe message) computation as a parameter, thus allowing for no message to be produced: . update state StartInc = do forkMaybe do delay (Milliseconds 1000.0) r &lt;- checkSomeCondition if r then pure (Just Inc) else pure Nothing pure state . For those effects that never produce any messages, regardless of external reasons, the function forkVoid may be used: . update state StartInc = do forkMaybe do delay (Milliseconds 1000.0) r &lt;- checkSomeCondition if r then pure (Just Inc) else pure Nothing forkVoid do Console.log \"Hello!\" pure state . NOTE: in the last code snippet the transition has two separate effects: one waits a second and then optionally produces the Inc message, and the other prints to console right away and produces no message. This is perfectly legal: a transition may have an arbitrary number of effects, and they all get executed in parallel. Finally, in the most complex cases, it may be necessary to produce multiple messages from a single computation. One example might be a long-running computation that reports its progress. For these cases, the most powerful forks function may be used. The forks function provides a callback that can be used to “issue” (or “dispatch”) a message. For example: . update state StartInc = do forks \\dispatch -&gt; do delay (Milliseconds 1000.0) dispatch Inc delay (Milliseconds 2000.0) dispatch Inc delay (Milliseconds 3000.0) dispatch Inc pure state . In this example the effectful computation produces one Inc message after a second, another one 2 seconds after that, and a third after 3 more seconds. ",
    "url": "/purescript-elmish/transition/#effects",
    "relUrl": "/transition/#effects"
  },"33": {
    "doc": "State Transitions",
    "title": "Under the hood",
    "content": "At the most fundamental level, Transition is a pair of “new state” and “array of effects”. This is how it’s defined: . data Transition msg state = Transition state (Array (Command msg)) type Command msg = (msg -&gt; Effect Unit) -&gt; Aff Unit . Here, the effects are called “commands”, but that’s not important. The name Effect was already taken. Every Command is an Aff computation that takes a msg -&gt; Effect Unit function as a parameter. This is exactly what the forks function takes. And indeed, all the forks function does is add its parameter to the current Transition’s array of commands. Based on this definition, a Transition equivalent to one of the above examples could also be constructed directly by applying the Transition constructor, like this: . update state Inc = Transition (state { count = state.count + 1 }) [] update state Dec = Transition (state { count = state.count - 1 }) [] update state StartInc = Transition state [incAfterDelay, printHello] where incAfterDelay dispatch = do delay (Milliseconds 1000.0) r &lt;- checkSomeCondition if r then dispatch (Just Inc) else pure unit printHello dispatch = Console.log \"Hello!\" . Here, the transitions for Inc and Dec contain no effects (note empty arrays), and the StartInc transition contains two: one optionally issuing an Inc message after a delay, and another printing “Hello” to the console. This way of constructing transitions is technically perfectly valid, but in real programs it gets ugly very quickly. This is why Transition is also a Monad, enabling the do notation, and this is why the convenience functions fork, forkMaybe, forkVoid, and forks exist. They are a more ergonomic facade for the underlying pair of state+commands. This is especially true when composing multiple components into one (aka “child components”). For a detailed exploration of different modes of composition, see Composition. ",
    "url": "/purescript-elmish/transition/#under-the-hood",
    "relUrl": "/transition/#under-the-hood"
  }
}
